import random

import cv2
import numpy as np
import torch

from scene.cameras import Camera
from cut_and_splat.utils.geometry import sample_sphere, normalize, Plane, rotate_point_around_vector
from utils.graphics_utils import getProjectionMatrix, getWorld2View2, focal2fov


def get_intrinsics(height, width, fov: float = 55.0):
    """
    Intrinsics for a pinhole camera model.
    Assume fov of 55 degrees and central principal point.
    """
    f = 0.5 * width / np.tan(0.5 * fov * np.pi / 180.0)
    cx = 0.5 * width
    cy = 0.5 * height
    return f, cx, cy


def filter_depth(rendering, mask, depth_map, depth_value):
    margin = (np.max(depth_map) - np.min(depth_map)) * 0.1
    depth_mask = depth_map > (depth_value - margin)
    depth_zero = depth_map == 0

    depth_mask = np.logical_or(depth_zero, depth_mask).astype(np.uint8)
    depth_mask = cv2.medianBlur(depth_mask, ksize=5).astype(np.float)
    depth_mask = cv2.GaussianBlur(depth_mask, ksize=(3,3), sigmaX=1.0)

    depth_mask = torch.Tensor(depth_mask).to(rendering.device)
    return rendering * depth_mask, mask * depth_mask


def look_at(eye: np.array, at: np.array, up: np.array):
    z_axis = normalize(at - eye)
    x_axis = normalize(np.cross(z_axis, up))
    y_axis = np.cross(x_axis, z_axis)

    y_axis = - y_axis

    R = np.array([
        [x_axis[0], x_axis[1], x_axis[2]],
        [y_axis[0], y_axis[1], y_axis[2]],
        [z_axis[0], z_axis[1], z_axis[2]]
    ])

    t = [-np.dot(x_axis, eye), -np.dot(y_axis, eye), -np.dot(z_axis, eye)]

    return R.transpose(), t


def generate_random_camera(camera: Camera, center: np.array, ground_plane: Plane, image_no: int, height=None, width=None, fovx=None, fovy=None):
    """
    Generate a random camera viewpoint looking at the given center
    Point is sampled from sphere with random radius centered around given center point
    Function ensures that point is above given plane
    """

    R, t = generate_random_view(center, ground_plane, min_dist=7.0, max_dist=20.0)

    target_image = camera.original_image if width is None or height is None else torch.zeros((1, height, width))
    cam_fovx = fovx if fovx is not None else camera.FoVx
    cam_fovy = fovy if fovy is not None else camera.FoVy

    return Camera(camera.colmap_id, R, t, cam_fovx, cam_fovy, target_image, gt_alpha_mask=None, image_name=str(image_no), uid=image_no)


def generate_random_view(center: np.array, ground_plane: Plane, min_dist: float = 7.0, max_dist: float = 25.0):
    up = ground_plane.normal
    point = sample_sphere(center, random.uniform(min_dist, max_dist))

    while ground_plane.distance(point) < 0.3:
        point = sample_sphere(center, random.uniform(min_dist, max_dist))

    R, t = look_at(point, center, up)

    return R, t


def generate_directed_view(camera: Camera, center: np.array, ground_plane: np.array, camera_dir: np.array, image_no: int, width=None, height=None, fovx=None, fovy=None, up=None, random_rot=False):
    """
    Create a camera viewpoint that looks towards the given center from the given camera direction
    Camera up is aligned with the given ground plane
    """
    up = ground_plane.normal if up is None else up
    camera_dir = camera_dir * 5

    if random_rot:
        camera_dir = rotate_point_around_vector(camera_dir, np.array([0,0,0]), up, random.randint(0, 360))

    point = center + camera_dir
    R, t = look_at(point, center, up)

    target_image = camera.original_image if width is None or height is None else torch.zeros((1, height, width))
    cam_fovx = fovx if fovx is not None else camera.FoVx
    cam_fovy = fovy if fovy is not None else camera.FoVy

    return Camera(camera.colmap_id, R, t, cam_fovx, cam_fovy, target_image, gt_alpha_mask=None,
           image_name=str(image_no), uid=image_no)


def move_camera(camera: Camera, offset):
    camera.T += offset
    camera.world_view_transform = torch.tensor(getWorld2View2(camera.R, camera.T, camera.trans, camera.scale)).transpose(0, 1).cuda()
    camera.projection_matrix = getProjectionMatrix(znear=camera.znear, zfar=camera.zfar, fovX=camera.FoVx, fovY=camera.FoVy).transpose(0, 1).cuda()
    camera.full_proj_transform = (camera.world_view_transform.unsqueeze(0).bmm(camera.projection_matrix.unsqueeze(0))).squeeze(0)
    camera.camera_center = camera.world_view_transform.inverse()[3, :3]


def camera_from_json(camera_data: dict):
    """
    Create a camera from a json dict generated by Gaussian Splatting
    """
    cam = Camera(
        colmap_id=camera_data['id'],
        R=np.array(camera_data['rotation']),
        T=np.array(camera_data['position']),
        FoVx=focal2fov(camera_data['fx'], camera_data['width']),
        FoVy=focal2fov(camera_data['fy'], camera_data['height']),
        image=torch.zeros((1, camera_data['height'], camera_data['width'])),
        gt_alpha_mask=None, image_name=str(0), uid=0
    )

    return cam